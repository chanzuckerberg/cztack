package main

import (
	"encoding/json"
	"fmt"
	"strings"

	"github.com/chanzuckerberg/go-misc/sets"
	"github.com/chanzuckerberg/terraform-provider-snowflake/pkg/resources"
)

const (
	testTemplate string = `package test

/*
 NOTE: automatically generated by scripts/snowflake_generate_grant_all.
			 Changes made directly to this file will be overwritten.
			 Make improvements there so everyone can benefit.
*/

import (
	"encoding/json"
	"testing"

	"github.com/chanzuckerberg/go-misc/tftest"
	"github.com/gruntwork-io/terratest/modules/terraform"
)

const vars string = %q
const onFutureVars string = %q

func TestModule(t *testing.T) {
	test := tftest.Test{
		Mode: tftest.Plan,

		Setup: func(t *testing.T) *terraform.Options {
			opts := &terraform.Options{
				TerraformDir: ".",
				EnvVars:      map[string]string{},
				Vars:         mustJson(vars),
			}
			return opts
		},
		Validate: func(t *testing.T, options *terraform.Options) {},
	}

	test.Run(t)
}

func TestModule_onFuture(t *testing.T) {
	if onFutureVars == "" {
		return // nothing to test, no future vars
	}
	test := tftest.Test{
		Mode: tftest.Plan,
		Setup: func(t *testing.T) *terraform.Options {
			opts := &terraform.Options{
				TerraformDir: ".",
				EnvVars:      map[string]string{},
				Vars:         mustJson(vars),
			}
			return opts
		},
		Validate: func(t *testing.T, options *terraform.Options) {},
	}

	test.Run(t)
}

func mustJson(jsonData string) map[string]interface{} {
	unmarshalled := map[string]interface{}{}

	err := json.Unmarshal([]byte(jsonData), &unmarshalled)
	if err != nil {
		panic(err) // should never happen since generated code
	}
	return unmarshalled
}
`
)

func hasOnFutureProperty(grant *resources.TerraformGrantResource) bool {
	_, ok := grant.Resource.Schema["on_future"]
	return ok
}

// generateFutureVars generates vars for on_future=true tests
func generateFutureTestVars(grant *resources.TerraformGrantResource) map[string]interface{} {
	vars := map[string]interface{}{}

	// no on-future so nothing to test here
	if !hasOnFutureProperty(grant) {
		return vars
	}

	conflictsWith := sets.NewStringSet().Add(grant.Resource.Schema["on_future"].ConflictsWith...)

	vars["on_future"] = true

	for name := range grant.Resource.Schema {
		// conflicts, skip
		if conflictsWith.ContainsElement(name) {
			continue
		}

		if strings.HasSuffix(name, "_name") {
			vars[name] = strings.TrimSuffix(name, "_name")
			continue
		}

		if name == "roles" {
			vars[name] = []string{"role_a", "role_b", "role_c"}
			continue
		}

		if name == "arguments" {
			vars[name] = []map[string]string{
				{
					"name": "foo",
					"type": "STRING",
				},
			}
			continue
		}
	}
	return vars
}

// generateVars currently generates vars for a basic integration test
// many input variable combinations are currently missing
func generateTestVars(grant *resources.TerraformGrantResource) map[string]interface{} {
	vars := map[string]interface{}{}

	for name := range grant.Resource.Schema {
		if strings.HasSuffix(name, "_name") {
			vars[name] = strings.TrimSuffix(name, "_name")
			continue
		}

		if name == "roles" {
			vars[name] = []string{"role_a", "role_b", "role_c"}
			continue
		}

		if name == "shares" {
			vars[name] = []string{"share_a", "share_b", "share_c"}
			continue
		}
	}

	return vars
}

func generateTest(grant *resources.TerraformGrantResource) (string, error) {
	vars := generateTestVars(grant)
	data, err := json.Marshal(vars)
	if err != nil {
		return "", err
	}

	futureData := []byte("")
	if hasOnFutureProperty(grant) {
		futureVars := generateFutureTestVars(grant)
		futureData, err = json.Marshal(futureVars)
		if err != nil {
			return "", err
		}
	}

	return fmt.Sprintf(testTemplate, string(data), string(futureData)), nil
}
